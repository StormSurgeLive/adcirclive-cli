#!/usr/bin/env perl
package bin::adclive;

use strict;
use warnings;
use Util::H2O::More qw/ddd h2o ini2h2o opt2h2o o2h/;
use HTTP::Tiny qw//;
use Getopt::Long qw//;
use Config::Tiny qw//;
use Digest::SHA qw/sha256_hex/;
use MIME::Base64 qw/encode_base64/;
use Time::HiRes qw//;
use JSON::PP qw/decode_json encode_json/;
use Dispatch::Fu;

our $VERSION = q{1.0};

use constant {
    EXIT_SUCCESS   => 0,
    EXIT_ERROR     => 255,
    DEFAULT_CONFIG => sprintf( qq{%s/asgs-global.conf}, ( getpwuid($<) )[7] ),    # $HOME/asgs-global.conf
    BASEURL        => q{https://stormreplay.com/api},
};

my $config     = ini2h2o DEFAULT_CONFIG;
my $subcommand = shift @ARGV;

# checks ref type, then returns dereferenced
# version of $_[0] (because that's all dispatch
# will take, single reference ...
sub xshift(@) {                               #TODO <~ add this to Dispatch::Fu, test, and add new release
  return %{+shift} if ref $_[0] eq q{HASH};
  return @{+shift} if ref $_[0] eq q{ARRAY};
  return shift @_  if ref $_[0] eq q{SCALAR};
}

#<<<
exit dispatch {
  my ($subcmd, $ARGV_ref, $config) = xshift @_;
  xdefault $subcmd, q{help};
} [ $subcommand, \@ARGV, $config ],
 on help => \&show_help,
 on uuid => \&get_uuid,
;
#>>>

sub get_uuid {
  my ($subcmd, $ARGV_ref, $config) = xshift @_;
  ddd $subcmd, $ARGV_ref, $config;

}

sub show_help {
  my ($subcmd, $ARGV_ref, $config) = xshift @_;
  ddd $subcmd, $ARGV_ref, $config;
};

__END__

sub _get_signed_user_agent {
    my $key    = $config->replayd->apikey;
    my $secret = $config->replayd->apisecret;

    # add $secret to string, get SHA256 hash
    my $nonce         = Time::HiRes::time * 100_000;
    my $signature     = sha256_hex( $nonce . $secret );
    my $authorization = encode_base64( sprintf( qq{%s:%s}, $key, $signature ), q{} );

    my $default_headers = {
        q{x-replayd-api-version} => q{1.0},
        q{x-auth-nonce}          => $nonce,
        q{Authorization}         => $authorization,
        q{Content-Type}          => q{application/json},
    };

    return HTTP::Tiny->new( ( default_headers => $default_headers ) );
}

1;
